# Preprocessing for Machine Learning
## Exploring missing data
###You've been given a dataset comprised of volunteer information from New York City, stored in the volunteer DataFrame. Explore the dataset using the plethora of methods and attributes pandas has to offer to answer the following question.
#How many missing values are in the locality column?
#Possible Answers
# 665
# 595 
# 70 <<---
# 35
'''
print(volunteer.isna().sum())
'''

##Droping Missing Data
###Now that you've explored the volunteer dataset and understand its structure and contents, it's time to begin dropping missing values.
###In this exercise, you'll drop both columns and rows to create a subset of the volunteer dataset.
###Instructions
###Drop the Latitude and Longitude columns from volunteer, storing as volunteer_cols.
###Subset volunteer_cols by dropping rows containing missing values in the category_desc, and store in a new variable called volunteer_subset.
###Take a look at the .shape attribute of volunteer_subset, to verify it worked correctly.

### Drop the Latitude and Longitude columns from volunteer
'''
volunteer_cols = volunteer.drop(["Latitude", "Longitude"], axis=1)
'''
### Drop rows with missing category_desc values from volunteer_cols
'''
volunteer_subset = volunteer_cols.dropna(subset=["category_desc"])
'''
### Print out the shape of the subset
'''
print(volunteer_subset.shape)
'''
#Exploring data types
###Taking another look at the dataset comprised of volunteer information from New York City, you want to know what types you'll be working with as you start to do more preprocessing.

###Which data types are present in the volunteer dataset?
'''
Floats and integers only
Integers only
Floats, integers, and objects <<------
Floats only
print(volunteer.dtypes)
'''
##Converting a column type
# If you take a look at the volunteer dataset types, you'll see that the column hits is type object. But, if you actually look at the column, you'll see that it consists of integers. Let's convert that column to type int.
#Instructions
#100 XP
#Take a look at the .head() of the hits column.
#Convert the hits column to type int.
#Take a look at the .dtypes of the dataset again, and notice that the column type has changed.

#Print the head of the hits column
print(volunteer["hits"].head())

#Convert the hits column to type int
volunteer["hits] = volunteer["hits"].astype(int)

#Look at the dtypes of the dataset
print(volunteer.dtypes)

##Class imbalance
#In the volunteer dataset, you're thinking about trying to predict the category_desc variable using the other features in the dataset. First, though, you need to know what the class distribution (and imbalance) is for that label.
#Which descriptions occur less than 50 times in the volunteer dataset?
#Possible Answers
# Emergency Preparedness
# Health
# Environment
# Environment and Emergency Preparedness  <<-----
# All of the above
print(volunteer.value_counts("category_desc")

## Stratified sampling
#You now know that the distribution of class labels in the category_desc column of the volunteer dataset is uneven. If you wanted to train a model to predict category_desc, you'll need to ensure that the model is trained on a sample of data that is representative of the entire dataset. Stratified sampling is a way to achieve this!
#Create a DataFrame of features, X, with all of the columns except category_desc.
#Create a DataFrame of labels, y from the category_desc column.
#Split X and y into training and test sets, ensuring that the class distribution in the labels is the same in both sets
#Print the labels and counts in y_train using .value_counts().

# Create a DataFrame with all columns except category_desc
X = volunteer.drop("category_desc", axis=1)

# Create a category_desc labels dataset
y = volunteer[["category_desc"]]

# Use stratified sampling to split up the dataset according to the y dataset
X_train, X_test, y_train, y_test = train_test_split(X, y, stratify=y, random_state=42)

#Note: stratify=y makes sure that the class labels are equally distributed in both training and test sets which is important for maintaining the same class distribution in both sets and helps evaluate the model performance more reliably
#Note: random_state=42 is a parameter to make sure that the split is reproducible (every time that it is ran, the same split will be made) this ensures consistency in testing and debugging

# Print the category_desc counts from y_train
print(y_train["category_desc"].value_counts())

###When to standardize
##Which is **not** a reason to standardize a dataset?
#A column you want to use for modeling has extremely high variance.
#You have a dataset with several continuous columns on different scales, and you'd like to use a linear model to train the data. 
#The models you're working with use some sort of distance metric in a linear space.
#Your dataset is comprised of categorical data.  <<---

##Modeling without normalizing
#Let's take a look at what might happen to your model's accuracy if you try to model data without doing some sort of standardization first.
#Here we have a subset of the wine dataset. One of the columns, Proline, has an extremely high variance compared to the other columns. This is an example of where a technique like log normalization would come in handy, which you'll learn about in the next section.
#The scikit-learn model training process should be familiar to you at this point, so we won't go too in-depth with it. You already have a k-nearest neighbors model available (knn) as well as the X and y sets you need to fit and score on.
#Instructions
#Split up the X and y sets into training and test sets, ensuring that class labels are equally distributed in both sets.
#Fit the knn model to the training features and labels.
#Print the test set accuracy of the knn model using the .score() method.

# Split the dataset into training and test sets
X_train, X_test, y_train, y_test = train_test_split(X, y, stratify=y, random_state=42)
knn = KNeighborsClassifier()

#Note: KNeighborsClassifier is an object created which is an instance of the k-nearest neighbors algorithm

# Fit the knn model to the training data
knn.fit(X_train, y_train)

#Note: the fit method is called on this object with X_train and y_train as arguments. This trains the k-nearest neighbors model using the training features (X_train) and the corresponding labels (y_trains)

# Score the model on the test data
print(knn.score(X_test, y_test))

#Note: the score method is used to evaluate the model's accuracy of the model of the test set comparing predicted labels for X_test with actualy labels y_test and the results printed gives the accuracy of the model on the test data. This score indicates how well the model is performing on unseen data, which is a crucial step in assessing the model's generalization capability

##Check the variance
#Check the variance of the columns in the wine dataset. Out of the four columns listed, which column is the most appropriate candidate for normalization?
#Possible Answers:
#Alcohol
#Proline <<---
#Proanthocyanins
#Ash
print(wine.var())

##Log normalizing in Python
#Now that we know that the Proline column in our wine dataset has a large amount of variance, let's log normalize it.
#numpy has been imported as np.
#Instructions
# Print out the variance of the Proline column for reference.
#Use the np.log() function on the Proline column to create a new, log-normalized column named Proline_log.
#Print out the variance of the Proline_log column to see the difference.

# Print out the variance of the Proline column
print(wine["Proline"].var())

# Apply the log normalization function to the Proline column
wine["Proline_log"] = np.log(wine["Proline"])

# Check the variance of the normalized Proline column
print(wine.Proline_log.var())

##Sclaling data - investigating columns
#You want to use the Ash, Alcalinity of ash, and Magnesium columns in the wine dataset to train a linear model, but it's possible that these columns are all measured in different ways, which would bias a linear model.
#Which of the following statements about these columns is true?
#Possible answers
#The standard deviation of Alcohol is greater than the standard deviation of Malic acid.
#The standard deviations of Ash and Alcalinity of ash are equal.
#The max of Ash is 3.23, the max of Alcalinity of ash is 30, and the max of Magnesium is 162. <<---
#The mean Malic acid is greater than the mean Ash.
wine[["Ash", "Alcalinity of ash", "Magnesium"]].describe()

#Instructions
#Import the StandardScaler class.
#Instantiate a StandardScaler() and store it in the variable, scaler.
#Create a subset of the wine DataFrame containing the Ash, Alcalinity of ash, and Magnesium columns, assign it to wine_subset.
#Fit and transform the standard scaler to wine_subset.

# Import StandardScaler
from sklearn.preprocessing import StandardScaler

# Create the scaler
scaler = StandardScaler()

#Note: StandardScaler is from skitlearn and will be used to standardize the features by removing the mean and scaling the unit variance. This is a common preprocessing step for many machine learning algorithms, including k-nearest neighbors, as it ensures that all features contribute equally to the distance calculations

# Subset the DataFrame you want to scale 
wine_subset = wine[["Ash", "Alcalinity of ash", "Magnesium"]]

# Apply the scaler to wine_subset
wine_subset_scaled = scaler.fit_transform(wine_subset)

##KNN on non-scaled data
#Before adding standardization to your scikit-learn workflow, you'll first take a look at the accuracy of a K-nearest neighbors model on the wine dataset without standardizing the data.
#The knn model as well as the X and y data and labels sets have been created already.
#Instructions
#Split the dataset into training and test sets.
#Fit the knn model to the training data.
#Print out the test set accuracy of your trained knn model.

# Split the dataset and labels into training and test sets
X_train, X_test, y_train, y_test = train_test_split(X, y, stratify=y, random_state=42)

# Fit the k-nearest neighbors model to the training data
knn.fit(X_train, y_train)

# Score the model on the test data
print(knn.score(X_test, y_test))

##KNN on scaled data
#The accuracy score on the unscaled wine dataset was decent, but let's see what you can achieve by using standardization. Once again, the knn model as well as the X and y data and labels set have already been created for you.
#Instructions
#Create the StandardScaler() method, stored in a variable named scaler.
#Scale the training and test features, being careful not to introduce data leakage.
#Fit the knn model to the scaled training data.
#Evaluate the model's performance by computing the test set accuracy.

# Instantiate a StandardScaler
scaler = StandardScaler()

# Scale the training and test features
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

# Fit the k-nearest neighbors model to the training data
knn.fit(X_train_scaled, y_train)

# Score the model on the test data
print(knn.score(X_test_scaled, y_test))
